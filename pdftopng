#!/usr/bin/perl
# PDFtoPNG - A simple PDF to PNG converter
# Copyright (C) Eskild Hustvedt 2007, 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Image::Magick;
use Getopt::Long;
use File::Path;
use File::Temp;
use File::Copy;
use File::Basename;
use IPC::Open3;
use Cwd;
Getopt::Long::Configure ('bundling');
require 5.8.0;

my $Tempdir;
my $OrigDir;
my $Version = "0.1.1";
my $ZipIt = 0;
my $TarBzipIt = 0;
my $TarIt = 0;
my $SilenceChild = 1;
my $NoFork;
my $BestCompression;
my $HTMLType;
my $HTML_NoResize;
my $ImageCache;
my %ReturnVals;
# This makes sure children are slayed properly and their return values
# are kept (in the %ReturnVals hash)
$SIG{CHLD} = sub {
	my $PID = wait;
	$ReturnVals{$PID} = $? >> 8;
	return(1);
};

$SIG{TERM} = \&SignalHandler;
$SIG{INT} = \&SignalHandler;

# Purpose: Handle various signals gracefully
# Usage: $SIG{SIGNAL} = \&SignalHandler;
sub SignalHandler {
	print "SIG$_[0] recieved. Cleaning up...";
	if(defined($Tempdir) and (-d $Tempdir) and (-w $Tempdir)) {
		rmtree($Tempdir);
	}
	print "done\n";
	print "Exiting.\n";
	exit(1);
}

# Purpose: Write HTML files with the images.
# Usage: WriteHTML(PAGES,TYPE, NAME);
sub WriteHTML {
	my($Pages, $Type, $Name) = @_;
	$Name =~ s/\.pdf$//;
	$Name = basename($Name);
	print "Writing HTML...";
	if($Type eq 'MULTI') {
		foreach my $Page (1..$Pages) {
			print ".";
			my($Last,$Next);
			if($Page > 1) {
				my $LastP = $Page;
				$LastP--;
				$LastP = ZeroPad($LastP);
				$Last = "$Name\_$LastP.html";
			}
			if(not $Page == $Pages) {
				my $NextP = $Page;
				$NextP++;
				$NextP = ZeroPad($NextP);
				$Next = "$Name\_$NextP.html";
			}
			$Page = ZeroPad($Page);
			HTML_WritePage($Page, $Name, "$Name\_$Page.html",$Last,$Next);
		}
	} elsif ($Type eq 'SINGLE') {
		HTML_WriteSinglePage($Pages, $Name, "$Name.html");
	} else {
		die("Unsupported WriteHtml type: $Type");
	}
	print "done\n";
}

# Purpose: Write all pages to the supplied HTML file
# Usage: HTML_WriteSinglePage(PAGES NAME, FILENAME);
sub HTML_WriteSinglePage {
	my ($Pages, $Name, $File) = @_;
	open(my $Target, ">", $File) or die("Unable to open $File for writing: $!\n");
	print $Target HTMLHeader(basename($Name));
	foreach my $CurrentPage (1..$Pages) {
		print $Target "<hr />";
		print $Target "<p><img alt='Page " . int($CurrentPage) . "' src='" . basename("$Name-" . ZeroPad($CurrentPage) . ".png'") . " /></p>";
		print $Target "<hr />\n";
	}
	print $Target "<p><br /><small><small>Generated by <a href='http://pdftopng.zerodogg.org/'>PDFtoPNG</a></small></small></p>";
	print $Target "</body></html>\n";
	close($Target);
}

# Purpose: Write a page to the supplied HTML file
# Usage: HTML_WritePage(PAGE_NO, NAME, FILENAME,PREV,NEXT);
sub HTML_WritePage {
	my ($Page, $Name, $File,$Prev,$Next) = @_;
	open(my $Target, ">", $File) or die("Unable to open $File for writing: $!\n");
	print $Target HTMLHeader(basename($Name));
	print $Target "<p>";
	if($Prev) {
		print $Target '<a href="' . $Prev . '">Last</a> - ';
	}
	if($Next) {
		print $Target '<a href="' . $Next . '">Next</a>';
	}
	print $Target "</p>";
	print $Target "<hr />";
	print $Target "<p><img alt='Page " . int($Page) . "' src='" . basename("$Name-" . ZeroPad($Page) . ".png'") . " /></p>";
	print $Target "<hr />";
	print $Target "<p>";
	if($Prev) {
		print $Target '<a href="' . $Prev . '">Last</a>';
	}
	if($Prev and $Next) {
		print $Target " - ";
	}
	if($Next) {
		print $Target '<a href="' . $Next . '">Next</a>';
	}
	print $Target "<br /><small><small>Generated by <a href='http://pdftopng.zerodogg.org/'>PDFtoPNG</a></small></small></p>";
	if($ImageCache) {
		print $Target "<p>";
		$Page++;
		my $Next = "$Name-" . ZeroPad($Page) . ".png";
		$Page++;
		my $AfterNext = "$Name-" . ZeroPad($Page) . ".png";
		if(-e $Next) {
			$Next = basename($Next);
			print $Target "<img src='$Next' alt='Cached image for later use ($Next)' style='width: 0px; height: 0px' />";
		}
		if(-e $AfterNext) {
			$AfterNext = basename($AfterNext);
			print $Target "<img src='$AfterNext' alt='Cache image for later use ($AfterNext)' style='width: 0px; height: 0px' />";
		}
		print $Target "</p>";
	}
	print $Target "</body></html>\n";
	close($Target);
}

# Purpose: Return the standard header used in the HTML pages
# Usage: HTMLHeader(TITLE);
sub HTMLHeader {
	my $Header = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' . "\n";
	$Header .= "<html xmlns='http://www.w3.org/1999/xhtml'><head>";
	$Header .= '<meta content="text/html; charset=iso-8859-1" http-equiv="content-type" />';
	$Header .= "<meta name='generator' content='PDFtoPNG $Version - http://pdftopng.zerodogg.org' />";
	if(not $HTML_NoResize) {
		$Header .= '<style type="text/css" media="screen">img{ width:100% }</style>';
	}
	$Header .= "<title>" . HTML_Encode($_[0]) . "</title>";
	$Header .= "</head>";
	$Header .= "<body>\n";
}

# Purpose: Encode special HTML entities
# Usage: HTML_Encode(STRING);
sub HTML_Encode {
	my $String = shift;
	study($String);
	$String =~ s/&/&amp;/;
	$String =~ s/</&lt;/;
	$String =~ s/>/&gt;/;
	$String =~ s/"/&quot;/;
	return($String);
}

# Purpose: Run a system() in a child (silencing it without using /bin/sh)
# Usage: SystemChild(OPTIONS);
#  OPTIONS are identical to system();
sub SystemChild {
	my $PID = fork;
	my $Return;
	if($PID) {
		waitpid($PID,0);
		$Return = $ReturnVals{$PID};
		delete($ReturnVals{$PID});
	} else {
		if($SilenceChild) {
			open(STDOUT, ">", "/dev/null");
			open(STDERR, ">", "/dev/null");
		}
		exec(@_);
	}
	return($Return);
}

# Purpose: Run a command, opening STDERR to STDOUT and
# 	capturing STDOUT+returning that.
# Usage: my ($Output, $ReturnVal) = CapturingSystem(OPTIONS);
#  OPTIONS are identical to system();
sub CapturingSystem {
	my ($Child_IN, $Child_OUT, $Child_ERR);
	my $PID = open3($Child_IN, $Child_OUT, $Child_ERR, @_) or die("Unable to open3(): $!\n");
	my $Returnme;
	while(<$Child_OUT>) {
		$Returnme .= $_;
	}
	if($Child_ERR) {
		while(<$Child_ERR>) {
			$Returnme .= $_;
		}
		close($Child_ERR);
	}
	close($Child_OUT);
	close($Child_IN);
	return($Returnme, $ReturnVals{$PID});
}

# Purpose: Calls ImageMagick convert to convert a PPM file to PNG
# Usage: $PID = ConvertPPM(FileName, PageNo,SaveInDir);
# 	Note: This function forks to speed up the program.
sub ConvertPPM {
	if(not $NoFork) {
		my $PID = fork;	# Fork
		return($PID) if($PID);
		open(STDIN, "<", "/dev/null");
		open(STDOUT, ">", "/dev/null");
		open(STDERR, ">", "/dev/null");
	}
	my($File, $Page,$SaveInDir,$OrigFile) = @_;
	$0 = "pdftopng - converting $Page to PNG";
	my $NewFile;
	if(not $ZipIt and not $TarBzipIt and not($TarIt)) {
		my $FileName = basename($OrigFile);
		$FileName =~ s/\.pdf$//i;
		$NewFile = "$FileName-$Page.png";
	} else {
		$NewFile = "$Page.png";
	}
	$NewFile = "$SaveInDir/$NewFile";
	my $Magic = Image::Magick->new;
	$Magic->Read($File);
	$Magic->Set(magick => "png");	# Output format
	$Magic->Write($NewFile);
	unlink($File);
	exit(0) if not $NoFork;
}

# Purpose: Adds proper padding with zeroes to a string
# Usage: $NewString = ZeroPad(STRING);
sub ZeroPad {
	my $String = shift;
	while(length($String) < 6) {
		$String = "0$String";
	}
	return($String);
}

# Purpose: Calls pdftoppm on a page
# Usage: PDFtoPPM(FILE, PAGE);
# 	Note: This function does *not* fork.
sub PDFtoPPM {
	my ($File, $Page) = @_;
	my ($Output,$Return) = CapturingSystem("pdftoppm", "-f", $Page, "-l", $Page, $File, "$Tempdir/");
	if(defined($Output) and $Output =~ /Error in JPX stream/i) {
		print "failed. Some parts of this page might have been lost - this is a common bug. See BUGS AND LIMITATIONS in the manpage. ";
	}elsif (not $Return) {
		print "done";
	}
	if($Return) {
		die("pdftoppm on $File page $Page failed!\nOutput: $Output\n");
	}
	print 
	return(1);
}

# Purpose: Gets the number of pages in the pdf
# Usage: $Pages = PDFPages($Filename);
sub PDFPages {
	my $Filename = shift;
	my $FileInfo = qx/pdfinfo $Filename/;
	foreach my $Pages (split(/\n/, $FileInfo)) {
		if($Pages =~ s/^Pages:\s+(\d+)$/$1/) {
			return($Pages);
		}
	}
	return(undef);
}

# Purpose: The main conversion loop, converts individual pages.
# Usage: ConvertFile(FILE);
sub ConvertFile {
	print "Preparing...";
	my $File = shift;
	my $Pages = PDFPages($File);
	my @Children;
	die("Unable to detect the number of pages in the file $File. Unable to continue.\n") unless $Pages;
	my $CurrentPage = 0;
	print "done\n";
	while($CurrentPage < $Pages) {
		$CurrentPage++;
		print "Converting page $CurrentPage/$Pages to PPM...";
		PDFtoPPM($File, $CurrentPage);
		print " Forking PPM to PNG converter...";
		my $PNGTargetDir;
		if($ZipIt or $TarBzipIt or $TarIt) {
			$PNGTargetDir = $Tempdir;
		} else {
			$PNGTargetDir = dirname($File);
		}
		push(@Children, ConvertPPM("$Tempdir/-" . ZeroPad($CurrentPage) . ".ppm", ZeroPad($CurrentPage),$PNGTargetDir, $File));
		print "done\n";
	}
	print "Waiting for child processes to finish...";
	foreach my $Child (@Children) {
		print ".";
		waitpid($Child,0);
	}
	print "done\n";
	if($HTMLType) {
		WriteHTML($Pages, $HTMLType, $File);
	}
	if($ZipIt) {
		ZipIt($File, $Pages);
	} elsif($TarBzipIt) {
		TarBzipIt($File, $Pages);
	} elsif($TarIt) {
		TarIt($File, $Pages);
	}
}

# Purpose: Create a cbz file
# Usage: ZipIt(ORIGINAL_FILENAME, TOTALPAGES);
sub ZipIt {
	chdir($Tempdir);
	my ($Name,$TotalPages) = @_;
	$Name =~ s/pdf$/cbz/i;
	my @PNGFiles;
	print "Writing $Name...";
	foreach(1..$TotalPages) {
		push(@PNGFiles, ZeroPad($_) . ".png");
	}
	unlink($Name) if -e ($Name);
	if($BestCompression) {
		SystemChild("zip", "-9", $Name, @PNGFiles);
	} else {
		SystemChild("zip", $Name, @PNGFiles);
	}
	print "done\n";
	print "Removing PNG files...";
	foreach(@PNGFiles) {
		print ".";
		unlink($_);
	}
	print "done\n";
	chdir($OrigDir);
}

# Purpose: Create a tbz file
# Usage: TarBzipIt(ORIGINAL_FILENAME, TOTALPAGES);
sub TarBzipIt {
	chdir($Tempdir);
	my ($Name,$TotalPages) = @_;
	$Name =~ s/\.pdf$//i;
	my @PNGFiles;
	print "Creating tarball...";
	foreach(1..$TotalPages) {
		push(@PNGFiles, ZeroPad($_) . ".png");
	}
	unlink("$Name.tar") if -e ("$Name.tar");
	unlink("$Name.tar.bz2") if -e ("$Name.tar.bz2");
	unlink("$Name.cbt") if -e ("$Name.cbt");
	if(SystemChild("tar", "-cvf", "$Name.tar", @PNGFiles)) {
		die("failed\n");
	}
	print "done. ";
	print "Removing PNG files...";
	foreach(@PNGFiles) {
		print ".";
		unlink($_);
	}
	print "done. ";
	print "Bzipping file...";
	if($BestCompression) {
		if(SystemChild("bzip2", "-9", "$Name.tar")) {
			die("failed\n");
		}
	} else {
		if(SystemChild("bzip2", "$Name.tar")) {
			die("failed\n");
		}
	}
	move("$Name.tar.bz2","$Name.cbt");
	print "done. Wrote $Name.cbt\n";
	chdir($OrigDir)
}

# Purpose: Create a tbz file
# Usage: TarBzipIt(ORIGINAL_FILENAME, TOTALPAGES);
sub TarIt {
	chdir($Tempdir);
	my ($Name,$TotalPages) = @_;
	$Name =~ s/\.pdf$//i;
	my @PNGFiles;
	print "Creating tarball...";
	foreach(1..$TotalPages) {
		push(@PNGFiles, ZeroPad($_) . ".png");
	}
	unlink("$Name.tar") if -e ("$Name.tar");
	unlink("$Name.cbt") if -e ("$Name.cbt");
	if(SystemChild("tar", "-cvf", "$Name.tar", @PNGFiles)) {
		die("failed\n");
	}
	print "done. ";
	print "Removing PNG files...";
	foreach(@PNGFiles) {
		print ".";
		unlink($_);
	}
	print "done. ";
	move("$Name.tar","$Name.cbt");
	print "done. Wrote $Name.cbt\n";
	chdir($OrigDir)
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Check for a file in path
# Usage: InPath(FILE)
sub InPath {
	foreach (split /:/, $ENV{PATH}) { if (-x "$_/@_" and ! -d "$_/@_" ) {	return 1; } } return 0;
}

# Purpose: Print the help screen
# Usage: HelpScreen();
sub HelpScreen {
	printf("pdftopng version $Version\nUsage: %s [OPTIONS] file.pdf\n\n",basename($0));
	PrintHelp("-z","--zip","Create a (cbz) comic book reader file (zip file)");
	PrintHelp("-b","--tbz","Create a (cbt) comic book reader file (bzipped tarball)");
	PrintHelp("-t","--tar","Create a (cbt) comic book reader file (uncompressed tarball)");
	PrintHelp("-c","--bestcomp","Compress files as much as possible (for use with -z or -t)");
	PrintHelp("-x","--xhtml", "Write one xhtml page for each page in the PDF file");
	PrintHelp("-i","--imghack", "Use a hack in the generated HTML pages making the browser cache the next");
	PrintHelp("","","image.");
	PrintHelp("-s","--singlehtml", "Write one xhtml page containing all the pages in the PDF file");
	PrintHelp("","--noresizehtml","Don't resize images to fit the screen when displaying the HTML pages");
	PrintHelp("","--nofork","Don't fork any background processes (this is slower)");
	PrintHelp("-h","--help","View this help screen");
	PrintHelp("-v","--verbose", "Don't silence zip, tar, bzip2 nor pdftoppm");
	PrintHelp("","--version","Display version information and exit");
	print "\nNote: Any existing files will be overwritten.\n";
}

GetOptions (
	'z|zip' => sub {
		$ZipIt = 1;
		die("zip is needed in \$PATH for --zip to function\n") unless InPath("zip");
	},
	'b|tbz' => sub {
		$TarBzipIt = 1;
		die("tar is needed in \$PATH for --tbz to function\n") unless InPath("tar");
		die("bzip2 is needed in \$PATH for --tbz to function\n") unless InPath("bzip2");
	},
	't|tar' => sub {
		$TarIt = 1;
		die("tar is needed in \$PATH for --tar to function\n") unless InPath("tar");
	},
	'x|xhtml' => sub {
		$HTMLType = 'MULTI';
	},
	's|singlehtml' => sub {
		$HTMLType = 'SINGLE';
	},
	'noresizehtml' => sub {
		$HTML_NoResize = 1;
	},
	'i|imghack' => \$ImageCache,
	'c|bestcomp' => \$BestCompression,
	'nofork' => \$NoFork,
	'h|help' => sub {
		HelpScreen();
		exit(0);
	},
	'v|verbose' => sub {
		$SilenceChild = 0;
	},
	'version' => sub {
		print "pdftopng version $Version\n";
		exit(0);
	},
) or die("See $0 --help for more information\n");

$| = 1;

die("Needs pdftoppm to function (comes with xpdf, check for an xpdf-tools package)\n") unless InPath("pdftoppm");
die("Needs pdfinfo to function (comes with xpdf, check for an xpdf-tools package)\n") unless InPath("pdfinfo");

die("Usage: $0 [OPTIONS] FILE.pdf\nSee $0 --help for more information\n") unless(@ARGV);

{
	my $Sets = 0;
	if($ZipIt) {
		$Sets++;
	}
	if($TarBzipIt) {
		$Sets++;
	}
	if($TarIt) {
		$Sets++;
	}
	die("You can only have one of --zip, --tar or --tbz, not all\n") unless($Sets == 0 or $Sets == 1);
	die("HTML exporting is not compatible with --zip, --tar or --tbz\n") if($Sets and $HTMLType);
}

$Tempdir = File::Temp::tempdir(
	"pdftopngXXXXXXXX", 
	CLEANUP => 1,
	TMPDIR => 1,
) or die($!);
$OrigDir = getcwd();

foreach(@ARGV) {
	%ReturnVals = ();
	die("$_: does not end with .pdf\n") unless /\.pdf$/;
	print basename($_) . ":\n" if @ARGV > 1;
	unless(-e $_ and -r $_) {
		die("$_: does not exist!\n");
	}
	ConvertFile(Cwd::realpath($_));
}
exit(0);
__END__
=encoding utf8

=head1 NAME

pdftopng - a PDF to PNG converter

=head1 SYNOPSIS

B<pdftopng> [I<OPTIONS>] file.pdf

=head1 DESCRIPTION

B<PDFtoPNG> converts a PDF file (or multiple PDF files) into individual PNG files, one
file per page. It can also
convert PDF files into *.cbz and *.cbt archives as used by comic book readers, and
write valid XHTML 1.0 strict pages.

The sizes of the resulting files will often be quite a bit larger than the
original PDFs, but will be faster to view (especially for graphically intensive
documents such as eComics).

=head1 OPTIONS

=over

=item B<-h, --help>

Display the help screen

=item B<-z, --zip>

Create a *.cbz archive instead of writing the PNG files to the current directory.
This is useful when you want to view the converted PDF in a comic book reader.
Creates one archive for each pdf file.

=item B<-b, --tbz>

Create a *.cbt archive instead of writing the PNG files to the current directory.
This CBT archive is really a *.tar.bz2 with another name.
This is useful when you want to view the converted PDF in a comic book reader.
This usually achieves better compression than --zip but is not as well
supported by all comic book readers as --zip.
Creates one archive for each pdf file.

=item B<-t, --tar>

Create a *.cbt archive instead of writing the PNG files to the current directory.
This CBT archive is really a *.tar with another name.
This is useful when you want to view the converted PDF in a comic book reader.
This option is uncompressed, but has the advantage of only needing one file
per-comic book. It is generally faster than both --zip and --tbz, but the files
will be larger (though often not much, possibly 5-10MB larger for every 100MB).
This is not as well supported by all comic book readers as --zip, but should
be just as well supported as --tbz.
Creates one archive for each pdf file.

=item B<-c, --bestcomp>

Compress files created with --tbz and --zip as much as possible. This
is slower than normal operation but might save more diskspace.
In many cases however, the gain from using --bestcomp is not really
noticeable.

=item B<-x, --xhtml>

Creates one additional page per page named documentname_PAGENUMBER.html.
This is a valid XHTML 1.0 Strict HTML document that can be used to view
the images in a webbrowser. By default the document is set to fit the image
to the width of the browser, some browsers end up with unreadable images
when this is used, if it is a problem use --noresizehtml to disable that
feature.

=item B<-i, --imghack>

This uses a simple hack in the generated HTML pages causing the browser reading
the page to cache the next image. What it does is include a <img> tag in the
document for the next pages' image aswell, but with a size of 0px. Thus the image
isn't displayed, but is still downloaded. This significantly improves loading time
as the page you want to display is usually cached in advance already. The generated page
should still be valid XHTML even when this is included, though this can hardly be
called a good way to use web standards.

=item B<-s,--singlehtml>

The same as --xhtml except that this writes all pages to one single large
XHTML file.

NOTE: This mode requires a fairly good computer (1GHz and above with a good chunk of memory)
to read the document on for PDFs above 20-30 pages. Use --xhtml for these machines.

=item B<--noresizehtml>

Tells PDFtoPNG not to add a CSS tag to the HTML documents that makes the images get resized
to fit the width of the browser window.

=item B<-v, --verbose>

Be verbose (don't silence calls to zip, tar, bzip2 nor pdftoppm).

=item B<--version>

Display version information and exit.

=back

=head1 BUGS AND LIMITATIONS

There is a limitation in the free PDF readers that causes some pages to not
render like they should (claiming "Error in JPX stream"), thus this limitation
is transferred over to PDFtoPNG. So there might be pages (especially for comics)
that will be partly not rendered or not rendered at all. There is nothing PDFtoPNG
can do with this problem, it must be fixed upstream.

=head1 DEPENDENCIES

Requires pdftoppm, pdfinfo and the Image::Magick perl module. zip is required for
--zip. tar and bzip2 is required for --tbz.

=head1 AUTHOR

B<PDFtoPNG> is written by Eskild Hustvedt <I<eskild at 
zerodogg dot org>>

=head1 LICENSE AND COPYRIGHT

Copyright (C) Eskild Hustvedt 2007

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
